---
layout: post
title: 2020-11-16-面向对象那点事：基于Python深入了解OOA、OOD、OOP
date: 2020-09-08
tags: 
      - Spider
      - Python
      - JavaScript
      - AJAX
      - js逆向
---

# <font face="楷体"  color='#e49123'> 面向对象那点事：基于Python深入了解OOA、OOD、OOP</font>

<p><font face="楷体" color='#e49123'>作者：Barranzi_</font></p>
<p><font face="楷体" color='#e49123'>个人github主页：[github](https://github.com/La0bALanG)</font></p>
<p><font face="楷体" color='#e49123'>个人邮箱：awc19930818@outlook.com</font></p>
<p><font face="楷体" color='#e49123'>新时代的铁饭碗：一辈子不管走到哪里都有饭吃(还能吃上热乎的)。——佚名</font></p>
<p><font face="楷体" color='red'> 免责声明：</font></p>
<p><font face='楷体' color='red'>		本系列笔记撰写初衷就是为了分享个人知识以及个人学习历程中的感悟及思考，所涉及到的内容`仅供学习与交流`，请勿用作`非法或商业用途`！由此引发的任何法律纠纷`后果自负`，与作者本人无关！</font></p>
<p><font face="楷体"  color='red'>版权声明：</font></p>
<p><font face='楷体' color='red'>		未经作者本人授权，禁止转载！请尊重原创！</font></p>
<p><font face="楷体" color='blue'>注：本文所有代码、案例测试环境：1.Linux -- 系统版本：Ubuntu20.04 LTS   2.windows -- 系统版本：WIN10 64位家庭版</font></p>
----------------------------------------------------------------------------

# 写在前面

​		程序猿，一个高大上中不失苦逼，牛x PLUS中不失煎熬的职业，一个让众多旁人羡煞不已的职业。我记得很早以前看过这样一个段子：要嫁就嫁程序员，为啥嘞？人傻钱多死的早。当然了，肯定是句玩笑话，但我们已经能够从中看出，社会对于程序员这个职位寄予的期望还是很高的。

​		程序员（英文Programmer）是从事程序开发、程序维护的专业人员。一般将程序员分为程序设计人员和程序编码人员，但两者的界限并不非常清楚，特别是在中国。软件从业人员分为[初级程序员](https://baike.baidu.com/item/初级程序员/441400)、中级程序员、高级程序员（现为软件设计师）、[系统分析员](https://baike.baidu.com/item/系统分析员/2296869)，[系统架构师](https://baike.baidu.com/item/系统架构师/3473607)，[测试工程师](https://baike.baidu.com/item/测试工程师/1907788)六大类(援引自百度百科，关键字：程序员)。

​		我个人觉得，程序员这个词，是一类专业从事软件相关行业的职位的习惯统称。其实说的再专业，对于一个程序猿，尤其是初级猿来说，其基本工作就是敲代码。从业这么多年，我见过形形色色的程序猿，有初入行的大学毕业生，有转行成功的小年轻，也有在某个开发领域摸爬滚打两三年，三四年的中年猿，也有已经小有成就的资深猿。除了最后这一类资深猿已步入成功人士行列，其余我见过的猿，他们早早晚晚都会遇到所谓的职业发展瓶颈：工作已两三年，三四年，还是个初级猿，想晋升，走技术路线，发现升上去很难；可是内心早已厌倦初级猿的那些活以及初级猿那可怜的行业最低标准薪水。为什么会难？初级猿，中级猿，走技术路线的晋升，无非就是向软件设计方向，即架构方向发展，可是架构设计，需要的不仅仅是扎实的编码功底，更重要的，是思想。国家软考，各位应该多少做过了解，国家软考分初，中，高级，其中中级软件设计师的难度是很高的，高级系统架构师就更别说了，这些级别的考试，其内容更加偏重的是编程理论与架构理论，诸如数据结构，编译原理，设计模式，面向对象程序设计等是重要的考试内容。而其中，面向对象程序设计是考察编程思想，编程理论的绝对重点。

​		编程思想，是一个程序猿最基本的生存技能。会写代码不重要，无非就是记记语法的事情，这很简单；会写“好”代码，这就很难了。老话说得好，思想高度决定上层建筑，优秀的编程思想，是高质量代码的有力保障。面向对象，作为当下90%的主流编程语言采用的编程思想，是所有程序员必须彻底熟练的技能。可以说，会写代码的猿不一定是个好猿(不一定完全理解面向对象)，但是(完全理解面向对象)一个好猿不仅会写代码，而且能写出高质量的代码。

​		基于此，特撰写这篇文章，跟大家一起聊聊理论，聊聊思想，聊聊面向对象。本文会从编程理论之一的数据结构出发，结合数据结构的基本理论，引入我们今天的主题。本文中，你会先对数据结构的基本理论做一个简单的了解，然后从数据结构基本理论我们引入面向对象的基本概念，了解完相关的基本概念之后，我们会重点介绍面向对象的三大特性，同时会针对Python面向对象相关的一些底层理论给各位做一个详细的介绍。紧接着我们会用大的篇幅讲解面向对象的六大设计原则，以及23+1种设计模式的实现原理及思想。本文，基本囊括面向对象所涉及到的所有知识点，篇幅较长，还请各位耐心阅读。好了废话不多说，我们先聊聊抽象数据类型。

# 抽象数据类型

## 浅析

​		在实际开发中，无论是设计所谓的xx管理系统，亦或是开发一个xx网站、APP，其实无非就是在跟数据打交道。而为了实现这些项目的开发，我们需要用到各种各样的编程语言，诸如C++，Java，Python，PHP……可是，在这些高级编程语言中，只有一些最最基本的数据类型，比如Python，有数字类型，字符型，序列，容器等，可是，仅凭这些基本数据类型，是无法满足我们的开发需求的，道理也很简单，难道只用这几种数据类型的数据，我就能开发出来一个网站？一个APP？当然不可能。这就是有关数据，产生的第一个问题：数据是否够用？

​		再比如，我独立开发出来了一个软件，哇很牛逼，非常受欢迎，那我肯定得指着他挣钱，但是为了让他挣钱就必须让他商业化，商业化意味着该软件必须投入使用，那么无论这个软件是C/S还是B/S架构，任何人都可以看得到你的源代码，甚至可以随意修改。显然，这是不安全的。这就是有关数据，产生的第二个问题：数据是否安全？何为安全，即：数据是否可以随意访问，数据内部是否可以随意修改？

​		再举例，比如我想开发一个电子控制系统，需要硬件，软件，硬件需要CPU，单片机，电源等等，软件需要采用c进行嵌入式开发；或者我想开发一个开关控制系统，也是需要硬件，软件，硬件同样也需要单片机，软件同样要用到c，那么问题来了：难道我每想做一个具体的产品，我都得一点一点的从头开始设计吗？这些软件之间是否有共性的问题呢？换句话表达：数据之间是否有共性呢？如何以数据为中心，如何围绕数据进行思考和设计？这就是有关数据，产生的第三个问题。

​		基于以上三个问题，我们现在引入抽象数据类型的概念。

## 定义

> **全称：Abstract Data Type**
>
> **中文名称：抽象数据类型**
>
> **英文简称：ADT**

- **百度百科定义**

  **抽象数据类型(ADT)**是指一个数学模型以及定义在此数学模型上的一组操作。**抽象数据类型需要通过固有数据类型（高级编程语言中已实现的数据类型）来实现。抽象数据类型是与表示无关的数据类型，是一个数据模型及定义在该模型上的一组运算。对一个抽象数据类型进行定义时，必须给出它的名字及各运算的运算符名，即函数名，并且规定这些函数的参数性质。一旦定义了一个抽象数据类型及其具体实现，程序设计中就可以像使用基本数据类型那样，十分方便地使用抽象数据类型

- **通俗解释**

  最开始的计算机语言，关注的都是如何更加有效率地计算，可以说其目的是计算层面的抽象。然而随着这个行业的不断发展，计算机不仅仅用于计算，开发也不仅只关注计算过程了，**数据层面**的抽象也变得同样重要。虽然计算机语言一开始就有对数据的抽象，但是那些都只是对一些最基本的数据类型而不包括我们想要用的，多种多样的数据。

  程序处理的数据，通常是不同的类型的。只有事先约定好不同类型的数据的存储方式，计算机才能正确理解逻辑上不同的数据类型。所有编程语言都会有一组内置的基本数据类型。另外在实际工作过程中，或早或晚总会碰到一些没法用现有数据类型解决的问题，这时就需要自定义一些数据类型来解决。像Python这样比较高级的语言，在基本类型的基础上还添加了一些额外的数据结构如tuple,list,dict（这些如果从广义上来说也算是Python的数据类型）。

  以上基本数据类型都是比较simple的结构，但是他们具有一个共通的问题，就是都会把数据暴露在外。这点类似于一个人如果有了对某个变量的权限的话他就可以看到这个变量代表的数据结构中的所有数据。而如果我们不希望被看到，那么这个问题可能就比较严重了。为了解决这个问题，就必须要有一种数据类型，它可以让使用者只需要考虑如何去使用，而不需要去关注类型内部的具体实现方式以及数据的表示等等。这样的类型从概念上来说就是抽象数据类型了。

- **抽象数据类型 = 逻辑结构+抽象运算。**

  逻辑结构，即我们所说的数据之间的逻辑关系，抽象运算，即我们赋予抽象数据类型能够提供的自定义“运算”（操作||功能）

  抽象数据类型，实质上，就是在描述问题本身，而跟计算机，是没有任何的关系的，也就是我们前面所说到的，脱离计算机，以数据为中心，围绕数据展开思考与设计。

  抽象数据类型存在的目标是什么？很简单，即：在不涉及具体的，和计算机系统相关的细节情况下，优先考虑，理解，思考问题本身，在此基础之上，实现用计算机求解问题的过程。

## 抽象数据类型的基本实现思路

- 基本思想

  实现一个抽象数据类型，其基本思想均是把数据定义为抽象的数据对象集合，只为他们定义可用的合法操作，而不暴露具体的内部细节。注意：不论是操作细节还是数据存储细节均不暴露

- 基本操作

  基于以上的基本实现思想，一般而言，抽象数据类型应该至少具备以下三种操作：

  - 构造操作：即如何通过抽象数据类型，创建抽象数据对象
  - 解析操作(也可以理解为获取操作)：一定会有一系列getxxx()方法去获取该抽象数据类型内部的任意数据及操作
  - 修改操作：一定会有一系列的setxxx()方法去给当前抽象数据类型修改任意数据及操作

- 引申：可变与不可变类型

  基于以上说到的三种基本操作，可以判断一个抽象数据类型的可变性

  - 如果一个抽象数据类型同时具备以上三种操作，那么这个抽象数据类型就是可变的
  - 如果一个抽象数据类型只具备一二两种操作，不具备第三种操作，那么这个抽象数据类型就是不可变的

- 思考：数据结构时抽象数据类型的物理实现

  基于以上抽象数据类型的所有内容，我们对这句话应该就不难理解了。抽象数据类型，是我们自定义的，区别于各大编程语言中的那些基本的数据类型，它高度自定义，可以存储任意数据，解决了开发过程中数据不够使用的问题，同时，抽象数据类型只提供功能，不提供类型内部的数据及操作的访问权限，解决了数据使用过程中的安全性问题，再者，抽象数据类型将开发过程中对计算机运算的关注转移到对数据的抽象，实现了以数据为中心的思考与设计。但，其终归只是一种类型。而在数据结构的概念中，一切的概念都是**围绕一个个具体的数据对象展开的**，这些数据对象，就是**通过一个个具体的抽象数据类型来创建的，由类型得到对象，由抽象的概念实例化出一个具体存在的数据，这个过程，就叫做物理实现。**所以，Clifford A.Shaffer在《数据结构与算法分析》一书中，对数据结构的定义是：“**数据结构是ADT（抽象数据类型Abstract Data Type） 的物理实现。**”

## 举例：抽象数据类型——复数

存储结构：

```python
class Complex(object):
    '''
        创建一个复数抽象数据类型
        定义成员：
            数据：实部，虚部
            操作：
                1.构造操作
                2.删除操作
                3.返回复数z实部值操作
                4.返回复数z虚部值操作
                ...
    '''
    def __init__(self):
        self.real;#定义实部
        self.imag;#定义虚部
    
    def AssignComplex(self,z,v1,v2):
        '''构造一个复数z'''
        pass
        ...
    
    def DestroyComplex(self,z):
        '''删除(销毁)一个复数z'''
        pass
        ...
    
    def getReal(self,z):
        '''返回复数z的实部值'''
        pass
        ...
    
    def getImag(self,z):
        '''返回复数z的虚部值'''
        pass
        ...
    ...

```

逻辑结构（采用二元组表示法）：

```
ADT Complex{
	数据对象：D={real,imag|real,imag均为实数}
	数据关系：R={<real，imag>|real是实部，imag是虚部}
	基本操作:
		AssignComplex(z,v1,v2):构造复数z
		DestroyComplex(z):删除(销毁)一个复数
		GetReal(z):返回复数z的实部
		GetImag(z):返回复数z的虚部
		…
}
```

## 抽象数据类型在Python中的实际应用——面向对象编程(Object Oriented Programming,简称OOP)

​		Python中，‘一切皆对象’。是对象，就有属性及方法。是对象，就有封装、继承、多态三大特性。这些都是套话了，理解起来其实也不难。但是，如果你不了解抽象数据类型，那么对于这些概念的理解你仍然只是理解了表象。

​		数据结构中，常见的逻辑结构，比如线性表，比如树形结构，比如图形结构，其本质，都是对象，都是一种抽象数据类型。我们所说的这些名词仅仅只是逻辑层面对这类对象的一个描述。而根据我们对于抽象数据类型的了解，其实现是需要基于现有的一些基本数据类型，比如整型，浮点型，字符串……同时，抽象数据类型实现了基本数据类型实现不了的数据对象的封装功能，其只对外提供功能接口但不会轻易提供访问抽象数据类型内部的方法及权限(至少一般用户是不具备这些方法及权限的)，并且抽象数据类型高度自定义，根据实际问题出发，基于数据解决问题，将传统的围绕计算为中心的设计转化为围绕问题本质、围绕数据为中心的设计，这些种种，其实就是面向对象的思想。

​		抽象数据类型与面向对象是有关系的，而且关系还很大。面向对象中类的概念主要来自于抽象数据类型理论，是基于抽象数据类型发展而来的。最基本的，抽象数据类型是一种以数据为中心的自定义类型，可提供相关属性与方法供直接使用。而面向对象中的类，是对现实对象进行的一个抽象化，将现实对象抽象成数据理论，从实物中提炼出对象的属性和行为，并在程序中用字段（属性）和方法（函数）描述出来。这一点，与抽象数据类型的理论恰恰是相辅相成的。同样的，抽象数据类型理论是为了解决数据的安全性问题，即解决基本数据类型存在的将数据本身暴露在外的问题。而面向对象中的类，封装是其三大特性之一，其就是为了解决类内部的成员，谁可以访问，谁不可以访问的问题，这一点上，又是不谋而合。再比如，抽象数据类型解决了基本数据类型解决不了的问题，即如何围绕问题本质、围绕数据进行程序设计。面向对象，其本身就是一种编程思想，其注重的就是功能，以功能为中心，注重解决问题的方法，围绕具体事务展开抽象，提炼属性与方法，并使用属性与函数进行描述，这一点，又不谋而合。

​		综上，抽象数据类型的基本理论奠定了面向对象的基本思想。接下来，我们从抽象数据类型开始出发，一步步开始面向对象的学习。后文所有内容的主线思路，都是围绕抽象数据类型展开。

# 面向对象基本概念

## 引言

​		我们举个例子：老安最近想买车了，同事这边有开丰田的，推荐卡罗拉双擎，油电混，省钱环保性价比高；有开哈弗的，推荐H5，买的人多各方面也不错；公司大领导独爱德系车型，推荐迈腾；家里老爹喜欢SUV，推荐逍客；老安自己觉得现在天津机动车牌照难摇不想等，想直接买新能源……车，是一个总称；丰田卡罗拉双擎，哈弗H5等等，是某一品牌的某一款具体车型；老安买到手的“新能源双座敞篷”爱玛大电摩，电动牌照号：5759717是一辆具体的车（电动咋的了- -、）。也就是说，车，是一类交通工具的总称，而具体的每一辆机动车，是车这个交通工具的某几个具体存在的实物。讲到这里，我们先看下面这个图：

![1605496391767](C:/Users/anwc/AppData/Roaming/Typora/typora-user-images/1605496391767.png)

​		在现实世界中，机动车，非机动车，自行车，电动车吧啦吧啦各种车，其实都是个车，即车，是这些具体车辆的总称，是一类交通工具，那么我可以在概念世界中抽象出来一个类型，叫车。车这个类型，有哪些具体的实体？汽车，自行车……，每一个具体的实体，是车这个类的某一个具体的实例。

​		好，讲到这里先解释一下上面出现的“抽象”这个词，什么叫抽象？从具体的事物抽出、概括出它们共同的特性，属性与关系等，而将个别的、非本质的方面舍弃，这种思维过程，就叫做抽象。

​		我们继续理解这个抽象的过程。

​		笔是某一类产品，只要能用来写字的都叫笔，那笔有哪些种？钢笔、中性笔、毛笔、签字笔……，这些笔都有一个共性，都能写字。那我们抽象一下，拿出他们的共性：能写字这个特点，然后抽象出一个概念：能写字的叫笔。

​		手机是某一类产品，只要能拿来打电话发短信的都叫手机，手机都有哪些种？三星NOTE 9、iPhone XS、华为P30 PRO……，这些产品都有这几个共性：都能打电话，发短信，上网，打游戏。那我们抽象一下，拿出他们的共性：打电话，发短信，上网，打游戏这些特点，然后抽象出一个概念：能打电话，发短信，上网，打游戏的都叫手机。

​		现实世界，存在着很多独立的实体，但是，总有若干个实体，具备很多相同或相似的，共性的特征，我们从现实世界中这些若干个具有共性特征的实体中，就可以抽象出一个概念：抽象数据类。这些抽象数据类，映射到计算机中，就是一个个具体的类，而这些若干个实体，映射到计算机中，就是一个个对象。由上图可以看到，类可以实例化一个或若干个对象，若干个对象也可以抽象为一个类。

​		为了帮助大家理解面向对象的基本概念，我们先了解什么叫面向过程。

## 面向过程

​		“面向过程”(Procedure Oriented)是一种以过程为中心的编程思想。“面向过程”也可称之为“面向记录”编程思想，他们不支持丰富的“[面向对象](https://baike.baidu.com/item/面向对象)”特性（比如继承、[多态](https://baike.baidu.com/item/多态)），并且它们不允许混合持久化状态和域逻辑。

​		面向过程以事件为中心，分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。

​		面向过程的程序设计思路：程序 = 数据结构 + 算法。即：做一件事，肯定伴随着数据的获取及调用以及每一步要做的具体的事是什么。计算机层面，即：设计一个程序，需要考虑两方面，第一，数据的存取操作；第二，算法的执行操作。

​		面向过程程序设计其实也是有优点的，比如对于复杂问题的流程化，进而实现对问题的简单化，再比如所有的细节自己掌控等等。但是，面向过程有其最致命的缺点：安全性低，可拓展性差。我们都知道，C是几乎绝大多数工科类专业大一的必修课，没错，C语言就是面向过程的。其特点：简洁紧凑，灵活方便，允许直接访问物理地址，可移植性好，执行效率高……,但，作为一门高级编程语言，其也有不可忽略且同样致命的缺点：数据的封装。C在数据的安全性上有非常大的缺陷，做一个假设：如果全程使用C做一个微信……乖乖，用户等死吧……

## 面向对象

- 定义

  面向[对象](https://baike.baidu.com/item/对象)(Object Oriented,OO)是[软件开发方法](https://baike.baidu.com/item/软件开发方法/971447)。面向[对象](https://baike.baidu.com/item/对象)的概念和应用已超越了[程序设计](https://baike.baidu.com/item/程序设计/223952)和软件开发，扩展到如[数据库系统](https://baike.baidu.com/item/数据库系统/215176)、交互式界面、应用结构、应用平台、[分布式系统](https://baike.baidu.com/item/分布式系统/4905336)、[网络管理](https://baike.baidu.com/item/网络管理/5903609)结构、CAD技术、[人工智能](https://baike.baidu.com/item/人工智能/9180)等领域。面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物。

- 理解

  面向对象与面向过程，是两种不同的编程思想。早期的计算机编程是基于面向过程的方法，例如实现算术运算1+1+2 = 4，通过设计一个算法就可以解决当时的问题。随着计算机技术的不断提高，计算机被用于解决越来越复杂的问题。一切事物皆对象，通过面向对象的方式，将现实世界的事物抽象成对象，现实世界中的关系抽象成类、[继承](https://baike.baidu.com/item/继承)，帮助人们实现对现实世界的[抽象](https://baike.baidu.com/item/抽象)与数据建模。通过面向对象的方法，更利于用人理解的方式对复杂系统进行分析、设计与编程。同时，面向对象能有效提高[编程](https://baike.baidu.com/item/编程)的效率，通过封装技术，消息机制可以像搭积木的一样快速开发出一个全新的系统。面向对象是指一种[程序设计范型](https://baike.baidu.com/item/程序设计范型)，同时也是一种程序开发的方法。对象指的是[类](https://baike.baidu.com/item/类)的集合。它将[对象](https://baike.baidu.com/item/对象)作为[程序](https://baike.baidu.com/item/程序)的基本单元，将程序和[数据](https://baike.baidu.com/item/数据)[封装](https://baike.baidu.com/item/封装)其中，以提高软件的重用性、灵活性和扩展性。

  起初，“面向[对象](https://baike.baidu.com/item/对象)”是专指在[程序设计](https://baike.baidu.com/item/程序设计)中采用[封装](https://baike.baidu.com/item/封装)、[继承](https://baike.baidu.com/item/继承)、[多态](https://baike.baidu.com/item/多态)等设计方法。

  面向[对象](https://baike.baidu.com/item/对象)的思想已经涉及到[软件开发](https://baike.baidu.com/item/软件开发)的各个方面。如，面向对象的分析（[OOA](https://baike.baidu.com/item/OOA)，Object Oriented Analysis），面向对象的设计（[OOD](https://baike.baidu.com/item/OOD)，Object Oriented Design）、以及我们经常说的面向对象的编程实现（[OOP](https://baike.baidu.com/item/OOP)，Object Oriented Programming）。

  面向[对象](https://baike.baidu.com/item/对象)的分析根据[抽象](https://baike.baidu.com/item/抽象)关键的问题域来分解系统。面向[对象](https://baike.baidu.com/item/对象)的设计是一种提供符号设计系统的面向对象的实现过程，它用非常接近实际领域术语的方法把系统构造成“现实世界”的对象。面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列[函数](https://baike.baidu.com/item/函数)的集合，或者直接就是一系列对电脑下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。

- 背景

  面向[对象](https://baike.baidu.com/item/对象)是在[结构化设计方法](https://baike.baidu.com/item/结构化设计方法)出现很多问题的情况下应运而生的。[结构化设计方法](https://baike.baidu.com/item/结构化设计方法)求解问题的基本策略是从功能的角度审视问题域。它将应用程序看成实现某些特定任务的[功能模块](https://baike.baidu.com/item/功能模块)，其中子过程是实现某项具体操作的底层功能模块。在每个功能模块中，用[数据结构](https://baike.baidu.com/item/数据结构)描述待处理数据的组织形式，用[算法](https://baike.baidu.com/item/算法)描述具体的操作过程。面对日趋复杂的应用系统，这种开发思路在下面几个方面逐渐暴露了一些弱点。

  1.审视问题域的视角

  在现实世界中存在的[客体](https://baike.baidu.com/item/客体)是问题域中的主角，所谓客体是指客观存在的[对象](https://baike.baidu.com/item/对象)实体和主观[抽象](https://baike.baidu.com/item/抽象)的概念，他是人类观察问题和解决问题的主要目标。例如，对于一个学校[学生管理系统](https://baike.baidu.com/item/学生管理系统)来说，无论是简单还是复杂，始终是围绕学生和老师这两个[客体](https://baike.baidu.com/item/客体)实施。在自然界，每个[客体](https://baike.baidu.com/item/客体)都具有一些属性和行为，例如学生有学号、姓名、性别等属性，以及上课、考试、做实验等行为。因此，每个个体都可以用属性和行为来描述。

  通常人类观察问题的视角是这些[客体](https://baike.baidu.com/item/客体)，客体的属性反应客体在某一时刻的状态，客体的行为反映客体能从事的操作。这些操作附在[客体](https://baike.baidu.com/item/客体)之上并能用来设置、改变和获取客体的状态。任何问题域都有一系列的[客体](https://baike.baidu.com/item/客体)，因此解决问题的基本方式是让这些客体之间相互驱动、相互作用，最终使每个客体按照设计者的意愿改变其属性状态。

  [结构化设计方法](https://baike.baidu.com/item/结构化设计方法)所采用的设计思路不是将[客体](https://baike.baidu.com/item/客体)作为一个整体，而是将依附于客体之上的行为抽取出来，以功能为目标来设计构造应用系统。这种做法导致在进行[程序设计](https://baike.baidu.com/item/程序设计)的时候，不得不将[客体](https://baike.baidu.com/item/客体)所构成的现实世界映射到由[功能模块](https://baike.baidu.com/item/功能模块)组成的解空间中，这种变换过程，不仅增加了程序设计的复杂程度，而且背离了人们观察问题和解决问题的基本思路。另外，再仔细思考会发现，在任何一个问题域中，[客体](https://baike.baidu.com/item/客体)是稳定的，而行为是不稳定的。例如，不管是国家图书馆，还是学校图书馆，还是国际图书馆，都会含有图书这个[客体](https://baike.baidu.com/item/客体)，但管理图书的方法可能是截然不同的。[结构化设计方法](https://baike.baidu.com/item/结构化设计方法)将审视问题的视角定位于不稳定的操作之上，并将描述[客体](https://baike.baidu.com/item/客体)的属性和行为分开，使得应用程序的日后维护和扩展相当困难，甚至一个微小的变动，都会波及到整个系统。面对问题规模的日趋扩大、环境的日趋复杂、需求变化的日趋加快，将利用计算机解决问题的基本方法统一到人类解决问题的习惯方法之上，彻底改变[软件设计](https://baike.baidu.com/item/软件设计)方法与人类解决问题的常规方式扭曲的现象迫在眉睫，这是提出面向[对象](https://baike.baidu.com/item/对象)的首要原因。

  2.[抽象](https://baike.baidu.com/item/抽象)级别

  [抽象](https://baike.baidu.com/item/抽象)是人类解决问题的基本法宝。良好的[抽象](https://baike.baidu.com/item/抽象)策略可以控制问题的复杂程度，增强系统的通用性和[可扩展性](https://baike.baidu.com/item/可扩展性)。[抽象](https://baike.baidu.com/item/抽象)主要包括过程抽象和数据抽象。[结构化设计方法](https://baike.baidu.com/item/结构化设计方法)应用的是过程[抽象](https://baike.baidu.com/item/抽象)。所谓过程[抽象](https://baike.baidu.com/item/抽象)是将问题域中具有明确功能定义的操作抽取出来，并将其作为一个实体看待。这种[抽象](https://baike.baidu.com/item/抽象)级别对于软件系统结构的设计显得有些武断，并且稳定性差，导致很难准确无误地设计出系统的每一个操作环节。一旦某个[客体](https://baike.baidu.com/item/客体)属性的表示方式发生了变化，就有可能牵扯到已有系统的很多部分。而数据[抽象](https://baike.baidu.com/item/抽象)是较过程抽象更高级别的抽象方式，将描述[客体](https://baike.baidu.com/item/客体)的属性和行为绑定在一起，实现统一的抽象，从而达到对现实世界客体的真正[模拟](https://baike.baidu.com/item/模拟)。

  3.[封装](https://baike.baidu.com/item/封装)体

  [封装](https://baike.baidu.com/item/封装)是指将现实世界中存在的某个[客体](https://baike.baidu.com/item/客体)的属性与行为绑定在一起，并放置在一个逻辑单元内。该逻辑单元负责将所描述的属性隐藏起来，外界对[客体](https://baike.baidu.com/item/客体)内部属性的所有访问只能通过提供的[用户接口](https://baike.baidu.com/item/用户接口)实现。这样做既可以实现对[客体](https://baike.baidu.com/item/客体)属性的保护作用，又可以提高[软件系统](https://baike.baidu.com/item/软件系统)的可维护性。只要用户接口不改变，任何[封装](https://baike.baidu.com/item/封装)体内部的改变都不会对[软件系统](https://baike.baidu.com/item/软件系统)的其他部分造成影响。[结构化设计方法](https://baike.baidu.com/item/结构化设计方法)没有做到[客体](https://baike.baidu.com/item/客体)的整体[封装](https://baike.baidu.com/item/封装)，只是封装了各个[功能模块](https://baike.baidu.com/item/功能模块)，而每个功能模块可以随意地对没有保护能力客体属性实施操作，并且由于描述属性的数据与行为被分割开来，所以一旦某个客体属性的表达方式发生了变化，或某个行为效果发生了改变，就有可能对整个系统产生影响。

  4.可重用性

  可[重用](https://baike.baidu.com/item/重用)性标识着软件产品的可复用能力，是衡量一个软件产品成功与否的重要标志。当今的软件开发行业，人们越来越追求开发更多的、更有通用性的可重用[构件](https://baike.baidu.com/item/构件)，从而使软件开发过程彻底改善，即从过去的语句级编写发展到现在的构件组装，从而提高软件开发效率，推动应用领域迅速扩展。然而，[结构化程序设计方法](https://baike.baidu.com/item/结构化程序设计方法)的基本单位是模块，每个模块只是实现特定功能的过程描述，因此，它的可重用单位只能是模块。例如，在[C语言](https://baike.baidu.com/item/C语言)编写程序时使用大量的[标准函数](https://baike.baidu.com/item/标准函数)。但对于今天的软件开发来说，这样的重用力度显得微不足道，而且当参与操作的某些[数据类型](https://baike.baidu.com/item/数据类型)发生变化时，就不能够再使用那些函数了。因此，渴望更大力度的可重用[构件](https://baike.baidu.com/item/构件)是如今应用领域对[软件开发](https://baike.baidu.com/item/软件开发)提出的新需求。

  上述弱点驱使人们寻求一种新的程序设计方法，以适应现代社会对[软件开发](https://baike.baidu.com/item/软件开发)的更高要求，面向[对象](https://baike.baidu.com/item/对象)由此产生。

## 基本概念

- 对象

  对象是人们要进行研究的任何事物，小到一颗沙粒，大到整个银河系，所有的一切，皆对象。对象不仅能够表示具体的事物，还能表示抽象的规划、计划或事件。

  - 对象具有状态，一个对象用数据值来描述它的状态
  - 对象还有行为，即操作，用于改变对象的状态，对象及其操作就是对象的行为
  - 对象实现了数据和操作的结合，使数据和操作封装于对象这个统一体中
  - 对象，是类的具体实例，即归属于某个类别的“个体”

- 类

  具有相同特性（[数据元素](https://baike.baidu.com/item/数据元素)）和行为（功能）的[对象](https://baike.baidu.com/item/对象)的[抽象](https://baike.baidu.com/item/抽象)就是类。因此，[对象](https://baike.baidu.com/item/对象)的[抽象](https://baike.baidu.com/item/抽象)是类，类的具体化就是对象，也可以说类的实例是对象，类实际上就是一种[数据类型](https://baike.baidu.com/item/数据类型)。

  - 类具有属性，它是[对象](https://baike.baidu.com/item/对象)的状态的[抽象](https://baike.baidu.com/item/抽象)，用[数据结构](https://baike.baidu.com/item/数据结构)来描述类的属性。

  - 类具有操作，它是[对象](https://baike.baidu.com/item/对象)的行为的[抽象](https://baike.baidu.com/item/抽象)，用操作名和实现该操作的方法来描述。

  - 类具有结构。在客观世界中有若干类，这些类之间有一定的结构关系。通常有两种主要的结构关系，即一般--具体结构关系，整体--部分结构关系。
    - ①一般--具体结构称为分类结构，也可以说是“或”关系，或者是“is a”关系。
    - ②整体--部分结构称为组装结构，它们之间的关系是一种“与”关系，或者是“has a”关系。

    通常，类与类之间的行为不同，对象与对象之间的数据不同。

    类是创建对象的模板。在面向对象的思想中，所有的对象（实例）都是由类创建的。

- 成员

  数据成员：名词类型的状态。（属性）

  方法成员：动词类型的行为。（方法）

- 类的实现语法

  ```python
  创建类：
  class 类名(object,[继承关系]):
      
      def __init__(self,[参数列表]):
          pass
      
      def 普通实例方法(self):
          pass
      ...
  实例化：
  类名()
  ```

- 说明

  --  类名所有单词首字母大写.

  --  _init_ 也叫构造函数，创建对象时被调用，也可以省略。

  --  self 变量绑定的是被创建的对象（获得的实例），名称可以随意。

## 类的成员

- 属性

  类的公有属性：

  在类的内部与外部，皆可以通过类及类的实例（对象）来进行访问；但是只能通过类来进行修改。

  ​       类的私有属性：

  在类的内部，皆可以通过类及类的实例（对象）来进行访问；

  在类的外部，无法通过类及类的实例（对象）来进行访问。

  ​       实例的公有属性：

  ​              在类的内部，无法通过类访问，但可以通过实例访问

  ​              在类的外部，无法通过类访问，但可以通过实例访问

  实例的私有属性：

  ​       在类的内部，无法通过类访问，但可以通过实例访问

  ​       在类的外部，无法通过类访问，也无法通过实例访问

  如下测试代码演示类的内部可能存在的属性及其测试调用：

  ```python
  class A(object):
      classVariable = '这是类属性，且是公有属性'
      __classVariable = '这是类属性，且是私有属性'
      def __init__(self):
          self.objectVariable = '这是实例属性，且是公有属性'
          self.__objectVatiable = '这是实例属性，且是私有属性'
      def test_in_all_variable(self):
          # 以下测试为：在类的内部部，对于类的公有属性、私有属性，实例的公有属性、私有属性调用情况
          # #######################
          # print(A.classVariable)
          # print(self.classVariable)
          # 测试类的公有属性在类的内部的调用情况
          # 结论：在类的内部，类的公有属性可以直接通过类或实例进行访问
          # ########################
          # print(A.__classVariable)
          # print(self.__classVariable)
          # 测试类的私有属性在类的内部的调用情况
          # 结论：在类的内部，类的私有属性可以直接通过类或实例进行访问
          #########################
          # print(A.objectVariable)
          # print(self.objectVariable)
          # 测试实例的公有属性在类的内部的调用情况
          # 结论：在类的内部，实例的公有属性无法直接通过类进行访问
          #       实例的公有属性可直接通过实例进行访问
          #########################
          # print(A.__objectVatiable)
          # print(a.__objectVatiable)
          # 测试实例的私有属性在类的内部的调用情况
          # 结论：在类的内部，实例的私有属性无法直接通过类进行访问
          #       实例的私有属性可直接通过实例进行访问
          #########################
  
  a = A()
  a.test_in_all_variable()
  
  # 以下测试为：在类的外部，对于类的公有属性、私有属性，实例的公有属性、私有属性调用情况
  ####################################
  # print(A.classVariable)
  # print(a.classVariable)
  # 测试类的公有属性在类的外部的调用情况
  # 结论：在类的外部，类的公有属性可直接通过类及类的实例访问
  ####################################
  # print(A.__classVariable)
  # print(a.__classVariable)
  # 测试类的私有属性在类的外部的调用情况
  # 结论:在类的外部,类的私有属性无法通过类及类的实例访问
  ####################################
  # print(A.objectVariable)
  # print(a.objectVariable)
  # 测试实例的公有属性在类的外部的调用情况
  # 结论:在类的外部,实例的公有属性不能通过类访问,可以通过实例访问
  ####################################
  # print(A.__objectVariable)
  # print(a.__objectVariable)
  # 测试实例的私有属性在类的外部的调用情况
  # 结论:在类的外部,实例的私有属性不能通过类访问,也不能通过实例访问
  ####################################
  
  ```

  现将上述测试内容辅以表格形式总结呈现：

  <style>
      td {	
          text-align:center;
      }
  </style>
  <table> 
      <tr>
          <td rowspan="2">区域/调用者</td>
          <td colspan="2">类的公有属性</td>
          <td colspan="2">类的私有属性</td>
          <td colspan="2">实例的公有属性</td>
          <td colspan="2">实例的私有属性</td>
      </tr>
      <tr>
          <td>类</td>
          <td>实例</td>
          <td>类</td>
          <td>实例</td>
          <td>类</td>
          <td>实例</td>
          <td>类</td>
          <td>实例</td>
      </tr>
      <tr>
          <td>类的内部</td>
          <td>√</td>
          <td>√</td>
          <td>√</td>
          <td>√</td>
          <td>×</td>
          <td>√</td>
          <td>×</td>
          <td>√</td>
      </tr>
      <tr>
          <td>类的外部</td>
          <td>√</td>
          <td>√</td>
          <td>×</td>
          <td>×</td>
          <td>×</td>
          <td>√</td>
          <td>×</td>
          <td>×</td>
      </tr>
  </table>

  - 内置属性
    - __dict__:类的属性，存储一个字典，字典中包含类当前的所有属性
    - __doc__:类的文档字符串
    - __name__:类名
    - __module__:类定义所在的模块（类的全名是'__main__.className'，如果类位于一个导入模块mymod中，那么className.__module__ 等于 mymod）
    - __bases__ : 类的所有父类构成元素（包含了以个由所有父类组成的元组）

- 方法

  类的公有方法：归属于类对象，类本身及类的实例皆可在类的内外部调用

  类的私有方法：归属于类对象，类本身及类的实例在类的内部可调用

  实例的公有方法：归属于实例，在类的内外部皆可由实例调用

  实例的私有方法：归属于实例，在类的内部可由实例调用

  初始化方法：__init__,初始化当前类所创建的实例

  析构方法：__del__,删除当前实例对象

  魔术方法：一系列的__开头__结尾的内置方法，无需手动调用，对类进行一系列操作时自动调用

  ​	__new__:真正的构造方法，用于创建当前类的实例对象

  ​	__str__、__repr__:两者的目的都是为了显式的显示对象的一些信息，方便查看和调试

  ​	__call__:将类对象变为可调用的对象，因为函数本身就是个对象，每一个函数都具备__call__方法。

  ​	__iter__、__next__：迭代器函数重写时使用，目的在于实现自定类的序列化

  ​	__getitem__、__setitem__、__delitem__：重写此三个方法可以将自定义类模拟成字典。

  ​	__getattr__、__setattr__、__delattr__：获取当前类的相关属性、设置当前类的相关属性、删除当前类的相关属性

  ​	…

  抽象方法：没有方法体的方法，常出现于抽象类中

  代码举例：

  ```python
  from abc import ABCMeta,abstractmethod
  class TestUseCase(object,metaclass=ABCMeta):
      '''测试类，用于展示类中可能出现的部分方法'''
      def __new__(cls, *args, **kwargs):
          '''__new__方法，用于构造(创建)实例对象'''
          return object.__new__(cls)
  
      def __init__(self):
          '''初始化方法，初始化当前实例'''
          pass
  
      def __call__(self, *args, **kwargs):
          '''__call__方法，用于实现类的可调用'''
          pass
  
      def __del__(self):
          '''析构方法，用于回收实例对象'''
          pass
  
      def __str__(self):
          '''显式显示对象信息'''
          pass
  
      def __repr__(self):
          '''显式显示对象信息'''
          pass
  
      ###################
      def __iter__(self):
          pass
  
      # 迭代器函数重写
  
      def __next__(self):
          pass
      ###################
  
      @classmethod
      def classMethodPublic(cls):
          '''类的公有方法'''
          pass
  
      @classmethod
      def __classMethodPrivate(cls):
          '''类的私有方法'''
          pass
  
      def objectMethodPublic(self):
          '''实例的公有方法'''
          pass
  
      def __objectMethodPrivate(self):
          '''实例的私有方法'''
          pass
  
      @staticmethod
      def staticMethod():
          '''静态方法'''
          pass
  
      @abstractmethod
      def abstractMethod(self):
          '''抽象方法'''
          pass
  
  ```

  

